<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta property="og:title" content="go tips &middot; waterdudu&#39;s blog ">
        <meta property="og:site_name" content="waterdudu&#39;s blog"/>
        <meta property="og:description" content="dudu&#39;s Site">
        <meta property="og:url" content="http://waterdudu.github.io/post/go-tips/" />
        <meta property="og:locale" content="en-us">
        <meta name="author" content="">
        <meta name="description" content="dudu&#39;s Site">
        <meta name="keywords" content="">
        <meta name="generator" content="Hugo 0.15" />
        <link rel="icon" href="http://waterdudu.github.io/assets/favicon.ico" type="image/x-icon"> 
        <link rel="stylesheet" href="http://waterdudu.github.io/css/slender-base.css">
        <link rel="stylesheet" href="http://waterdudu.github.io/css/slender-color-schemes.css">
        <link rel="stylesheet" href="http://waterdudu.github.io/css/font-awesome-4.5.0.min.css">
        <link rel="stylesheet" href="http://waterdudu.github.io/css/highlight-9.0.0-default.min.css">
        <title>
            
                go tips &middot; waterdudu&#39;s blog
            
        </title>
    </head>
    <body class="color-scheme-white">
        <div class="container">
            <header>
                <nav>
                    <ul></ul>
                </nav>
                
                    <h1 class="title">go tips</h1>
                    <aside>
                        <p>on <strong>Mon, Jan 18, 2016</strong></p>
                    </aside>
                
            </header>
<article class="article-content">
    

<h3 id="资源:a2653e2feb85ac0f67b04a4d51202bc4">资源</h3>

<ul>
<li><a href="https://github.com/golang/go/wiki/">github.com/golang/go/wiki</a></li>
<li><a href="https://golang.org/doc/faq">go faq</a></li>
<li><a href="http://www.golangbootcamp.com/book/">golang bootcamp</a></li>
<li><a href="http://go-database-sql.org/">go database-sql</a></li>
<li><a href="https://golang.org/doc/effective_go.html">effective go</a></li>
</ul>

<h3 id="访问-map-的-key-value:a2653e2feb85ac0f67b04a4d51202bc4">访问 map 的 key, value</h3>

<pre><code>x := map[string]string{
    &quot;name&quot;: &quot;dudu&quot;,
    &quot;love&quot;: &quot;many&quot;,
}

if _, ok := x[&quot;love&quot;]; !ok {
    fmt.Println(&quot;a person with no love&quot;)
}
</code></pre>

<h3 id="修改-string-时-转换成-slice:a2653e2feb85ac0f67b04a4d51202bc4">修改 string 时，转换成 slice</h3>

<pre><code>x := &quot;strings are read-only&quot;
xbytes := []byte(x)
xbytes[0] = 'S'

fmt.Println(string(xbytes))
</code></pre>

<h3 id="以下调用合法:a2653e2feb85ac0f67b04a4d51202bc4">以下调用合法</h3>

<ul>
<li>调用 pointer receiver method，只要调用者是 pointer type，或者它能被取地址（&amp;）</li>
<li>调用 value recieiver method，只要调用者是 value type，或者它的 value 可以被取值（*）</li>
</ul>

<p>The rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.</p>

<pre><code>type List [] int

func (l List) Len() int { return len(l) }
func (l *List) Append(val int) { *l = append(*l, val) }

// call
var list List
list.Append(l)
fmt.Printf(&quot;%v (len: %d) \n&quot;, list, list.Len())

pList := new(List)
pList.Append(2)
fmt.Printf(&quot;%v (len: %d) \n&quot;, pList, pList.Len())

</code></pre>

<h3 id="for-range-string:a2653e2feb85ac0f67b04a4d51202bc4">for range string</h3>

<p>for range 默认会把 string 当作 utf-8 字符，如果不能解析，则返回 0xfffd。
需要把它转换成 byte slice 让结果正确。</p>

<pre><code>data := &quot;A\xfe\x02\xff\x04&quot;
for _,v := range data {
    fmt.Printf(&quot;%#x &quot;,v)
}
//prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)

fmt.Println()
for _,v := range []byte(data) {
    fmt.Printf(&quot;%#x &quot;,v)
}
//prints: 0x41 0xfe 0x2 0xff 0x4 (good)
</code></pre>

<h3 id="for-range-map-随机:a2653e2feb85ac0f67b04a4d51202bc4">for range map 随机</h3>

<pre><code>m := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3, &quot;four&quot;: 4}
for k, v := range m {
    fmt.Println(k, v)
}

// first time run

// [ run | done: 9.628665ms ]
//  one 1
//  two 2
//  three 3
//  four 4


// second time run

// [ run | done: 8.847101ms ]
//  three 3
//  four 4
//  one 1
//  two 2
</code></pre>

<h3 id="switch:a2653e2feb85ac0f67b04a4d51202bc4">switch</h3>

<p>switch 默认是 fallthrough 的，可以在 case 语句里写成 list，或者使用 fallthrough 语句</p>

<pre><code class="language-go">isSpace := func(ch byte) bool {
    switch(ch) {
    case ' ', '\t':
        return true
    }
    return false
}
</code></pre>

<h3 id="i:a2653e2feb85ac0f67b04a4d51202bc4">++i</h3>

<p>go 不支持 prefix increment or decrement</p>

<h3 id="struct-field-是-map-或者-pointer-时的修改:a2653e2feb85ac0f67b04a4d51202bc4">struct field 是 map 或者 pointer 时的修改</h3>

<p>struct field 是 map 或者 pointer 时，可以通过 value method 修改</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type data struct {  
    num int
    key *string
    items map[string]bool
}

func (this *data) pmethod() {  
    this.num = 7
}

func (this data) vmethod() {  
    this.num = 8
    *this.key = &quot;v.key&quot;
    this.items[&quot;vmethod&quot;] = true
}

func main() {  
    key := &quot;key.1&quot;
    d := data{1,&amp;key,make(map[string]bool)}

    fmt.Printf(&quot;num=%v key=%v items=%v\n&quot;,d.num,*d.key,d.items)
    //prints num=1 key=key.1 items=map[]

    d.pmethod()
    fmt.Printf(&quot;num=%v key=%v items=%v\n&quot;,d.num,*d.key,d.items) 
    //prints num=7 key=key.1 items=map[]

    d.vmethod()
    fmt.Printf(&quot;num=%v key=%v items=%v\n&quot;,d.num,*d.key,d.items)
    //prints num=7 key=v.key items=map[vmethod:true]
}
</code></pre>

<h3 id="处理-http-request-的-close:a2653e2feb85ac0f67b04a4d51202bc4">处理 http request 的 close</h3>

<p>同时判断 err 和 resp
redirect 失败时 resp, err 都 != nil，此时需要对 resp 做出错处理，关闭 resp.Body</p>

<pre><code class="language-go">resp, err := http.Get(&quot;https://api.ipify.org?format=json&quot;)
if resp != nil {
    defer resp.Body.Close()
}

if err != nil {
    fmt.Println(err)
    return
}

defer resp.Body.Close()//ok, most of the time :-)
body, err := ioutil.ReadAll(resp.Body)
if err != nil {
    fmt.Println(err)
    return
}

fmt.Println(string(body))
</code></pre>

<h3 id="close-http-connection:a2653e2feb85ac0f67b04a4d51202bc4">close http connection</h3>

<p>标准库会根据 server 的配置来关闭 connection，这会导致我们的 app 的性能。
以下方式关闭 http 链接。</p>

<p>向同一个 server 发送很多请求时可以设置连接open。
向很多 server 发送请求时需要关闭连接来保证性能（或者增加 open file limit）。</p>

<ul>
<li>设置 Close = true</li>
</ul>

<p><code>req.Close = true</code></p>

<ul>
<li>添加 request header</li>
</ul>

<p><code>req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)</code></p>

<pre><code class="language-go">req, err := http.NewRequest(&quot;GET&quot;,&quot;http://golang.org&quot;,nil)
if err != nil {
    fmt.Println(err)
    return
}

req.Close = true
//or do this:
//req.Header.Add(&quot;Connection&quot;, &quot;close&quot;)

resp, err := http.DefaultClient.Do(req)
if resp != nil {
    defer resp.Body.Close()
}

</code></pre>

<h3 id="json-number-decode:a2653e2feb85ac0f67b04a4d51202bc4">json number decode</h3>

<p>json 默认把数字 decode 成 float64，如需把它当作 int 使用时有以下几种方式：</p>

<ul>
<li>float64 =&gt; int</li>
</ul>

<pre><code class="language-go">var data = []byte(&quot;{\&quot;status\&quot;: 200}&quot;)

var result map[string]interface{}
if err := json.Unmarshal(data, &amp;result); err != nil {
    fmt.Println(&quot;error:&quot;, err)
    return
}

var status = uint64(result[&quot;status&quot;].(float64)) //ok
</code></pre>

<ul>
<li>use a Decoder type to unmarshal JSON, represent JSON numbers using the Number interface type</li>
</ul>

<pre><code class="language-go">  var data = []byte(&quot;{\&quot;status\&quot;: 200}&quot;)

  var result map[string]interface{}
  var decoder = json.NewDecoder(bytes.NewReader(data))
  decoder.UseNumber()

  if err := decoder.Decode(&amp;result); err != nil {
    fmt.Println(&quot;error:&quot;, err)
    return
  }

  var status,_ = result[&quot;status&quot;].(json.Number).Int64() //ok
</code></pre>

<ul>
<li>use the string representation of your Number value to unmarshal it to a different numeric type</li>
</ul>

<pre><code class="language-go">var data = []byte(&quot;{\&quot;status\&quot;: 200}&quot;)

var result map[string]interface{}
var decoder = json.NewDecoder(bytes.NewReader(data))
decoder.UseNumber()

if err := decoder.Decode(&amp;result); err != nil {
    fmt.Println(&quot;error:&quot;, err)
    return
}

var status uint64
if err := json.Unmarshal([]byte(result[&quot;status&quot;].(json.Number).String()), &amp;status); err != nil {
    fmt.Println(&quot;error:&quot;, err)
    return
}

</code></pre>

<ul>
<li>use a struct type that maps your numeric value to the numeric type you need.</li>
</ul>

<pre><code class="language-go">  var data = []byte({&quot;status&quot;: 200}`)

  var result struct {
    Status uint64 \`json:&quot;status&quot;\`
  }

  if err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result); err != nil {
    fmt.Println(&quot;error:&quot;, err)
    return
  }
</code></pre>

</article>
        </div>
        <footer>
            <p>Copyright 2015 &copy; waterdudu</p>
        </footer>
        <script src="http://waterdudu.github.io/js/highlight-9.0.0.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        
    </body>
</html>