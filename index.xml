<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on waterdudu blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://waterdudu.github.io/</link>
    <language>en-us</language>
    <author>dudu</author>
    
    <updated>Mon, 18 Jan 2016 13:41:35 CST</updated>
    
    <item>
      <title>go tips</title>
      <link>http://waterdudu.github.io/post/go-tips/</link>
      <pubDate>Mon, 18 Jan 2016 13:41:35 CST</pubDate>
      <author>dudu</author>
      <guid>http://waterdudu.github.io/post/go-tips/</guid>
      <description>

&lt;h3 id=&#34;访问-map-的-key-value:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;访问 map 的 key, value&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;x := map[string]string{
    &amp;quot;name&amp;quot;: &amp;quot;dudu&amp;quot;,
    &amp;quot;love&amp;quot;: &amp;quot;many&amp;quot;,
}

if _, ok := x[&amp;quot;love&amp;quot;]; !ok {
    fmt.Println(&amp;quot;a person with no love&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改-string-时-转换成-slice:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;修改 string 时，转换成 slice&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;x := &amp;quot;strings are read-only&amp;quot;
xbytes := []byte(x)
xbytes[0] = &#39;S&#39;

fmt.Println(string(xbytes))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;以下调用合法:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;以下调用合法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;调用 pointer receiver method，只要调用者是 pointer type，或者它能被取地址（&amp;amp;）&lt;/li&gt;
&lt;li&gt;调用 value recieiver method，只要调用者是 value type，或者它的 value 可以被取值（*）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;type List [] int

func (l List) Len() int { return len(l) }
func (l *List) Append(val int) { *l = append(*l, val) }

// call
var list List
list.Append(l)
fmt.Printf(&amp;quot;%v (len: %d) \n&amp;quot;, list, list.Len())

pList := new(List)
pList.Append(2)
fmt.Printf(&amp;quot;%v (len: %d) \n&amp;quot;, pList, pList.Len())

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for-range-string:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;for range string&lt;/h3&gt;

&lt;p&gt;for range 默认会把 string 当作 utf-8 字符，如果不能解析，则返回 0xfffd。
需要把它转换成 byte slice 让结果正确。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    data := &amp;quot;A\xfe\x02\xff\x04&amp;quot;
    for _,v := range data {
        fmt.Printf(&amp;quot;%#x &amp;quot;,v)
    }
    //prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)

    fmt.Println()
    for _,v := range []byte(data) {
        fmt.Printf(&amp;quot;%#x &amp;quot;,v)
    }
    //prints: 0x41 0xfe 0x2 0xff 0x4 (good)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for-range-map-随机:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;for range map 随机&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    m := map[string]int{&amp;quot;one&amp;quot;: 1, &amp;quot;two&amp;quot;: 2, &amp;quot;three&amp;quot;: 3, &amp;quot;four&amp;quot;: 4}
    for k, v := range m {
        fmt.Println(k, v)
    }

    // first time run
    
    // [ `run` | done: 9.628665ms ]
    //  one 1
    //  two 2
    //  three 3
    //  four 4


    // second time run

    // [ `run` | done: 8.847101ms ]
    //  three 3
    //  four 4
    //  one 1
    //  two 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;switch:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;switch&lt;/h3&gt;

&lt;p&gt;switch 默认是 fallthrough 的，可以在 case 语句里写成 list，或者使用 fallthrough 语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    isSpace := func(ch byte) bool {
        switch(ch) {
        case &#39; &#39;, &#39;\t&#39;:
            return true
        }
        return false
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;i:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;++i&lt;/h3&gt;

&lt;p&gt;go 不支持 prefix increment or decrement&lt;/p&gt;

&lt;h3 id=&#34;未导出的-field-的-encode-decode:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;未导出的 field 的 encode/decode&lt;/h3&gt;

&lt;p&gt;未导出的 field 不能被 encode，decode 的时候被初始化为 zero value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;encoding/json&amp;quot;
)

type MyData struct {  
    One int
    two string
}

func main() {  
    in := MyData{1,&amp;quot;two&amp;quot;}
    fmt.Printf(&amp;quot;%#v\n&amp;quot;,in) //prints main.MyData{One:1, two:&amp;quot;two&amp;quot;}

    encoded,_ := json.Marshal(in)
    fmt.Println(string(encoded)) //prints {&amp;quot;One&amp;quot;:1}

    var out MyData
    json.Unmarshal(encoded,&amp;amp;out)

    fmt.Printf(&amp;quot;%#v\n&amp;quot;,out) //prints main.MyData{One:1, two:&amp;quot;&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;struct-field-是-map-或者-pointer-时的修改:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;struct field 是 map 或者 pointer 时的修改&lt;/h3&gt;

&lt;p&gt;struct field 是 map 或者 pointer 时，可以通过 value method 修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type data struct {  
    num int
    key *string
    items map[string]bool
}

func (this *data) pmethod() {  
    this.num = 7
}

func (this data) vmethod() {  
    this.num = 8
    *this.key = &amp;quot;v.key&amp;quot;
    this.items[&amp;quot;vmethod&amp;quot;] = true
}

func main() {  
    key := &amp;quot;key.1&amp;quot;
    d := data{1,&amp;amp;key,make(map[string]bool)}

    fmt.Printf(&amp;quot;num=%v key=%v items=%v\n&amp;quot;,d.num,*d.key,d.items)
    //prints num=1 key=key.1 items=map[]

    d.pmethod()
    fmt.Printf(&amp;quot;num=%v key=%v items=%v\n&amp;quot;,d.num,*d.key,d.items) 
    //prints num=7 key=key.1 items=map[]

    d.vmethod()
    fmt.Printf(&amp;quot;num=%v key=%v items=%v\n&amp;quot;,d.num,*d.key,d.items)
    //prints num=7 key=v.key items=map[vmethod:true]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;处理-http-request-的-close:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;处理 http request 的 close&lt;/h3&gt;

&lt;p&gt;同时判断 err 和 resp
redirect 失败时 resp, err 都 != nil，此时需要对 resp 做出错处理，关闭 resp.Body&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    resp, err := http.Get(&amp;quot;https://api.ipify.org?format=json&amp;quot;)
    if resp != nil {
        defer resp.Body.Close()
    }

    if err != nil {
        fmt.Println(err)
        return
    }

    defer resp.Body.Close()//ok, most of the time :-)
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println(string(body))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;close-http-connection:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;close http connection&lt;/h3&gt;

&lt;p&gt;标准库会根据 server 的配置来关闭 connection，这会导致我们的 app 的性能。
以下方式关闭 http 链接。&lt;/p&gt;

&lt;p&gt;向同一个 server 发送很多请求时可以设置连接open。
向很多 server 发送请求时需要关闭连接来保证性能（或者增加 open file limit）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置 Close = true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;req.Close = true&lt;/code&gt;
* 添加 request header&lt;/p&gt;

&lt;p&gt;&lt;code&gt;req.Header.Add(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    req, err := http.NewRequest(&amp;quot;GET&amp;quot;,&amp;quot;http://golang.org&amp;quot;,nil)
    if err != nil {
        fmt.Println(err)
        return
    }

    req.Close = true
    //or do this:
    //req.Header.Add(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)

    resp, err := http.DefaultClient.Do(req)
    if resp != nil {
        defer resp.Body.Close()
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;json-number-decode:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;json number decode&lt;/h3&gt;

&lt;p&gt;json 默认把数字 decode 成 float64，如需把它当作 int 使用时有以下几种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;float64 =&amp;gt; int&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

var result map[string]interface{}
if err := json.Unmarshal(data, &amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
}

var status = uint64(result[&amp;quot;status&amp;quot;].(float64)) //ok
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;use a Decoder type to unmarshal JSON, represent JSON numbers using the Number interface type&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result map[string]interface{}
  var decoder = json.NewDecoder(bytes.NewReader(data))
  decoder.UseNumber()

  if err := decoder.Decode(&amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }

  var status,_ = result[&amp;quot;status&amp;quot;].(json.Number).Int64() //ok
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;use the string representation of your Number value to unmarshal it to a different numeric type&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

var result map[string]interface{}
var decoder = json.NewDecoder(bytes.NewReader(data))
decoder.UseNumber()

if err := decoder.Decode(&amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
}

var status uint64
if err := json.Unmarshal([]byte(result[&amp;quot;status&amp;quot;].(json.Number).String()), &amp;amp;status); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;use a struct type that maps your numeric value to the numeric type you need.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  var data = []byte(`{&amp;quot;status&amp;quot;: 200}`)

  var result struct {
    Status uint64 `json:&amp;quot;status&amp;quot;`
  }

  if err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;amp;result); err != nil {
    fmt.Println(&amp;quot;error:&amp;quot;, err)
    return
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;use a struct that maps your numeric value to the json.RawMessage type if you need to defer the value decoding.
这个条件判断时有用（如 status 可能是 200 也可能是 ok）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    records := [][]byte{
        []byte(`{&amp;quot;status&amp;quot;: 200, &amp;quot;tag&amp;quot;:&amp;quot;one&amp;quot;}`),
        []byte(`{&amp;quot;status&amp;quot;:&amp;quot;ok&amp;quot;, &amp;quot;tag&amp;quot;:&amp;quot;two&amp;quot;}`),
    }

    for idx, record := range records {
        var result struct {
            StatusCode uint64
            StatusName string
            Status     json.RawMessage `json:&amp;quot;status&amp;quot;`
            Tag        string          `json:&amp;quot;tag&amp;quot;`
        }

        if err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;amp;result); err != nil {
            fmt.Println(&amp;quot;error:&amp;quot;, err)
            return
        }

        var sstatus string
        if err := json.Unmarshal(result.Status, &amp;amp;sstatus); err == nil {
            result.StatusName = sstatus
        }

        var nstatus uint64
        if err := json.Unmarshal(result.Status, &amp;amp;nstatus); err == nil {
            result.StatusCode = nstatus
        }

        fmt.Printf(&amp;quot;[%v] result =&amp;gt; %+v\n&amp;quot;, idx, result)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;template:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;template&lt;/h3&gt;

&lt;p&gt;template 加载可以有多种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Parse&lt;/li&gt;
&lt;li&gt;ParseFiles&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
type Tag struct {
    TName string
}
type Person struct {
    FirstName string
    LastName  string
    Age       int
    Emails    []string
    Tags      []*Tag
}

func main() {
    t1 := Tag{TName: &amp;quot;java&amp;quot;}
    t2 := Tag{TName: &amp;quot;go&amp;quot;}
    t := template.New(&amp;quot;persion tag example&amp;quot;)
    t, _ = t.Parse(`person with tags {{.FirstName}} !
        {{range .Emails}}
            email : {{.}}
        {{end}}
        {{with .Tags}}
            {{range .}}
                tag is : {{.TName}}
            {{end}}
        {{end}}
    `)
    p := Person{
        FirstName: &amp;quot;d&amp;quot;,
        LastName:  &amp;quot;X&amp;quot;,
        Emails:    []string{&amp;quot;a@gmail.com&amp;quot;, &amp;quot;b@gmail.com&amp;quot;},
        Tags:      []*Tag{&amp;amp;t1, &amp;amp;t2},
    }

    t.Execute(os.Stdout, p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;person with tags d !
            email : a@gmail.com
            email : b@gmail.com
                tag is : java
                tag is : go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;组合-template:a2653e2feb85ac0f67b04a4d51202bc4&#34;&gt;组合 template&lt;/h3&gt;

&lt;p&gt;把一个页面分成 layout 和 content，layout 负责布局， content 负责展示内容&lt;/p&gt;

&lt;p&gt;content.gtpl 定义了 template 名字：content&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-content.gtpl&#34;&gt;{{define &amp;quot;content&amp;quot;}}
&amp;lt;ul&amp;gt;
    {{range .}}
        &amp;lt;li&amp;gt;{{.FirstName}} {{.LastName}} is {{.Age}} years old.
        {{.FirstName}}&#39;s full name is {{printf &amp;quot;%s%s&amp;quot; .FirstName .LastName | len}} letters long.
        In 10 years, {{.FirstName}} will be {{add .Age 10}}.&amp;lt;/li&amp;gt;
    {{end}}
&amp;lt;/ul&amp;gt;
{{end}}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;layout.gtpl 使用 content.gtpl 定义的 content template&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-layout.gtpl&#34;&gt;&amp;lt;div class=&amp;quot;outer&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{.Title}}&amp;lt;/h1&amp;gt;
    {{template &amp;quot;content&amp;quot; .Content}}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 go 文件中使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;os&amp;quot;
    &amp;quot;text/template&amp;quot;
)

type Person struct {
    FirstName string
    LastName  string
    Age       int
}

func add(a int, b int) int {
    return a + b
}

type Page struct {
    Title   string
    Content interface{}
}

var layout, contentPage *template.Template

func init() {
    layout = template.Must(template.ParseFiles(&amp;quot;layout.gtpl&amp;quot;)).Funcs(
        template.FuncMap{
            &amp;quot;add&amp;quot;: add,
        })

    contentPage = template.Must(layout.Clone())
    contentPage = template.Must(peoplePage.ParseFiles(&amp;quot;content.gtpl&amp;quot;))
}

func main() {
    // content
    var people = []Person{
        {&amp;quot;John&amp;quot;, &amp;quot;Smith&amp;quot;, 22},
        {&amp;quot;Alice&amp;quot;, &amp;quot;Smith&amp;quot;, 25},
        {&amp;quot;Bob&amp;quot;, &amp;quot;Baker&amp;quot;, 24},
    }
    var title string = &amp;quot;Hey man&amp;quot;
    contentPage.Execute(os.Stdout, Page{
        Title:   title,
        Content: people,
    })
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>photomosaic</title>
      <link>http://waterdudu.github.io/post/photomosaic/</link>
      <pubDate>Sat, 14 Nov 2015 23:49:14 CST</pubDate>
      <author>dudu</author>
      <guid>http://waterdudu.github.io/post/photomosaic/</guid>
      <description>

&lt;h1 id=&#34;just-another-photo-mosaic-app:4ecaecb9a929be0046d2b8fa3b2964e3&#34;&gt;Just another photo mosaic app&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Hallstatt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;post-avatar&#34; alt=&#34;&#34; src=&#34;http://waterdudu.github.io/img/village.png&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vatican&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;post-avatar&#34; alt=&#34;&#34; src=&#34;http://waterdudu.github.io/img/castle.jpg&#34;&gt;
&lt;strong&gt;Sanlitun&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;post-avatar&#34; alt=&#34;&#34; src=&#34;http://waterdudu.github.io/img/chinese_art.jpg&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>swiftwordpolicy</title>
      <link>http://waterdudu.github.io/post/swiftwordpolicy/</link>
      <pubDate>Sat, 07 Nov 2015 10:09:13 CST</pubDate>
      <author>dudu</author>
      <guid>http://waterdudu.github.io/post/swiftwordpolicy/</guid>
      <description>&lt;p&gt;Privacy Policy (effective date October 4, 2015)
Privacy Policy of SwiftWord&lt;/p&gt;

&lt;p&gt;About This Policy&lt;/p&gt;

&lt;p&gt;This privacy policy describes the privacy practices of the website and apps published by SwiftWord Developer, which includes a link to this policy.&lt;/p&gt;

&lt;p&gt;Personal Information Collection: Apps published by SwiftWord Developer will not collect any personal information.&lt;/p&gt;

&lt;p&gt;Personal Information Sharing: Apps published by SwiftWord Developer may not share personal information about consumers with third parties for their own marketing purposes unless the consumer agreed to that sharing.&lt;/p&gt;

&lt;p&gt;Children’s Online Privacy Protection Act
Our mobile applications comply with the Children’s Online Privacy Protection Act (“COPPA”). We don’t knowingly collect personal information from children under the age of 13 years old. If a user is identified as under 13 years old, we will not collect or use any information of this user and we will delete any information already received in a secure manner.&lt;/p&gt;

&lt;p&gt;Other Privacy Related Issues: Apps published by SwiftWord Developer may contain links to other sites or applications which are owned or run by 3rd parties. SwiftWord Developer will not be responsible for those linked sites or application.&lt;/p&gt;

&lt;p&gt;Changes on Privacy Policy&lt;/p&gt;

&lt;p&gt;If we change or update the privacy policy to allow SwiftWord Developer to use or share your previously collected personal information in a different way, we will update the Policy on this web page. We encourage you to periodically visit this page for the latest privacy practices.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>first</title>
      <link>http://waterdudu.github.io/post/first/</link>
      <pubDate>Fri, 06 Nov 2015 22:45:04 CST</pubDate>
      <author>dudu</author>
      <guid>http://waterdudu.github.io/post/first/</guid>
      <description>&lt;p&gt;hey first&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
